'use strict';

var map = require('ramda/src/map');
var merge = require('ramda/src/merge');
var times = require('ramda/src/times');
var prop = require('ramda/src/prop');
var sort = require('ramda/src/sort');
var useWith = require('ramda/src/useWith');
var pipe = require('ramda/src/pipe');
var apply = require('ramda/src/apply');

var Select1 = require('./select1');
var Select2 = require('./select2');

var defaultConfig = {
  optimize: Math.max,
  select1: Select1.bestOf2,
  select2: Select2.bestOf2,
  mutate: function mutate(x) {
    return x;
  },
  crossover: function crossover(a, b) {
    return [a, b];
  },

  populationSize: 250,
  crossoverChance: 0.9,
  mutateChance: 0.2,
  fittestAlwaysSurvives: true
};

var chance = function chance(fraction) {
  return Math.random() <= fraction;
};

var comparator = function comparator(optimize) {
  return function (a, b) {
    return optimize(a, b) === a ? -1 : 1;
  };
};

function Evolutionary(config) {
  var c = merge(defaultConfig, config);

  var calcFitness = function calcFitness(individual) {
    return { individual: individual, fitness: c.fitness(individual) };
  };

  var mapFitness = map(calcFitness);

  var getFitness = prop('fitness');
  var getIndividual = prop('individual');

  var sortPop = sort(useWith(comparator(c.optimize), [getFitness, getFitness]));

  var initPop = pipe(function () {
    return times(c.seed, c.populationSize);
  }, mapFitness, sortPop, map(getIndividual));

  var calcAndOrderPop = pipe(mapFitness, sortPop);

  var maybeMutate = function maybeMutate(individual) {
    return c.mutate && chance(c.mutateChance) ? c.mutate(individual) : individual;
  };

  // c, pop -> individual
  var selectMaybeMutated = pipe(c.select1, getIndividual, maybeMutate);

  // c, pop -> [individual, individual]
  var selectCrossoverChildren = pipe(c.select2, map(getIndividual), map(maybeMutate), apply(c.crossover));

  return function evolve(pop) {
    if (!pop) pop = initPop();
    pop = mapFitness(pop);

    var newPop = [];

    if (c.fittestAlwaysSurvives) newPop.push(pop[0].individual);

    while (newPop.length < c.populationSize) {
      if (c.crossover && chance(c.crossoverChance) && newPop.length + 1 < c.populationSize) {
        newPop.push.apply(newPop, selectCrossoverChildren(c, pop));
      } else {
        newPop.push(selectMaybeMutated(c, pop));
      }
    }

    return map(getIndividual, calcAndOrderPop(newPop));
  };
}

module.exports = Evolutionary;